%second chapter of your thesis
\chapter{Moeilijkheden}
\subchapter{Software}
Het probleem met de integrator is iets waar we niet dieper op zijn ingegaan en niet hebben opgelost. Het probleem dat zich voordoet is het feit de I-waarde die we genereren, telkens de som is van de fout die zich voordoet. Aangezien de code meer dan 1000 keer per seconde wordt uitgevoerd kan deze waarde in een mum van tijd een extreem grote waarden aannemen wat niet gunstig is voor de robot. Het effect van dit probleem op onze robot was dat hij plots extreem versnelde en onmiddellijk alle controle verloor. We zouden dit probleem kunnen oplossen door de I-waarde voldoende klein te kiezen en eventueel slechts om de zoveel tijd deze waarde aan te passen. Na herhaaldelijke pogingen om dit probleem op te lossen hebben we ingezien dat de I-waarde geen noodzakelijk onderdeel is voor een stabiel rijdende robot en hebben we dus besloten dit weg te laten.

Op het moment dat we onze PD-waarden aan het optimaliseren waren, is er een kortsluiting ontstaan in onze Arduino en motor shield terwijl de batterij was aangesloten. De batterij heeft toen een te grote stroom door beide printplaten gestuurd waardoor deze stuk gingen. Ook 3 sensoren hebben toen de brui gegeven. We hebben toen een hele middag gezocht of er een mogelijkheid was om alsnog het motor shield te herstellen aangezien er geen werkende shields op overschot waren. Jammer genoeg was het de L298 die stuk was en hebben we dan een motor shield gekregen waarbij het kroonsteentje stuk was. Na een kleine opknapbeurt hadden we opnieuw een werkende motorshield ter onze beschikking. Onze PD-waarden waren hierdoor weer niet optimaal en hebben dus 2 dagen verloren aan dit gebeuren.

Aangezien we gebruik maken van 2 armen voor het detecteren van beide lijnen van het parcours ontstaat er het probleem dat er 1 arm een hogere prioriteit heeft ten opzichte van de andere arm. De code die we ge\"implementeerd hebben zorgt ervoor dat de rechterarm prioriteit heeft boven de linkerarm aangezien de code voor de rechterarm eerst wordt uitgevoerd. Van zodra er 1 sensor actief is van deze arm, zal de code voor de registratie van de sensoren van de linkerarm zelfs niet meer uitgevoerd worden. Dit heeft er voor gezorgd dat onze robot een voorkeursrichting, namelijk tegenwijzerzin, heeft waarin hij met grotere zekerheid de parcours foutloos zal kunnen afleggen. Wanneer we de buitenbocht volgen, wat meestal het geval is, dan bestaat de kans dat bij een plotse scherpe bocht naar links, de robot onvoldoende corrigeert en daardoor met zowel zijn rechterarm, de buitenlijn detecteert, als met zijn linkerarm, de middellijn detecteert. Deze situatie zou tot geen probleem leiden aangezien zijn rechterarm prioritair is en dus de wit-detectie van zijn linkerarm teniet gedaan wordt. Omgekeerd daarentegen, wanneer links de buitenbocht is bijvoorbeeld 010 100, en hij komt met zijn rechterarm op de middellijn terecht, dan zal de robot de verkeerde kant uitschieten aangezien hij met een grote factor wordt gecorrigeerd omdat de sensor die de extreme situatie voorstelt, oplicht. Gelukkig zijn de sensor-armen instelbaar en konden we per circuit de richting en afstand van de armen instellen om zo optimale prestaties te verkrijgen zonder het probleem van prioriteit uit de kant te ruimen. Een mogelijkheid om dit probleem aan te pakken was om bij te houden met een boolean welke arm er actief is en welke arm er net nieuw contact maakt met de witte lijn. De arm die bijvoorbeeld al het langst actief was, kunnen we dan als prioritaire arm beschouwen en elke keer dat we de situatie 000 000 tegenkomen, wat overeenkomt met alle sensoren die zich in het zwart bevinden, kan de prioriteit van de arm opnieuw ingesteld worden.

Voor het eenvoudigste, ovale circuit hadden we onze code geoptimaliseerd op 72. Deze snelheid komt overeen met 0.48 m/s en was een zeer hoge snelheid als je onze robot zag rondrijden. Wanneer we vervolgens het 2e circuit te zien kregen werd het duidelijk dat de robot dit circuit niet aan deze snelheid zou kunnen afleggen. We verlaagden onze snelheid dan naar 65, zodat de robot zonder fouten dit 2e circuit zou kunnen afleggen. Deze snelheidsvermindering ging ook gepaard met nieuwe PD-waarden en we konden met andere woorden opnieuw beginnen met het instellen van de robot. Het probleem waar we nu mee te maken kregen, is dat we een lager vermogen hadden voor de motoren en dus bij sommige grote bulten een duwtje moesten geven om onze robot zijn rit te laten verderzetten. De snelheid opdrijven, zou resulteren in het opnieuw aanpassen van de error values en PD-waarden, waardoor we besloten genoegen te nemen met een snelheid van 0.28 m/s.

Op het moment dat onze printplaat, Arduino gecombineerd met een motor shield, klaar was, wilden we de RFID-lezer connecteren met de Arduino. We stuitten op het probleem dat de RFID-lezer gebruik maakt van de pinnen: 9, 10, 11,12 en 13 terwijl we onze printplaat reeds geroute hadden waarbij de pinnen 11 12 en 13 intern verbonden waren met de L298. Dit vormde een groot probleem aangezien het voor de RFID-lezer niet mogelijk was gebruik te maken van andere pinnen aangezien die gebruikt maakt van SPI. Dit probleem konden we oplossen door onze routing volledig opnieuw te doen waarbij we andere pinnen zouden gebruiken om de L298 aan te sturen. Aangezien daar geen tijd voor was, bedachten we dat we konden gebruik maken van een andere hulp-Arduino die instond voor het lezen van de RFID-tags en voor het verzenden via UART naar de hoofd-Arduino. Deze hoofd-Arduino verloor met als gevolg dus slechts 1 pin, namelijk de RX-pin, aan het lezen van de RFID-tags. Aangezien we voordien reeds een prototype-Arduino gemaakt hadden, konden we deze gebruiken als hulp-Arduino en konden we op het einde van de rit alsnog ons project afronden waarbij we enkel gebruik maakten van zelfgemaakte printplaten.

Wanneer we data via Bluetooth verzonden van de Raspberry Pi naar de Arduino en omgekeerd stootten we op het probleem dat er regelmatig karakters fout waren ontvangen en de communicatie dus niet optimaal was. We hebben vervolgens trachten te achterhalen wat het probleem exact was. We merkten op dat de RX- en TX-pinnen, waaraan wij de Bluetooth module hadden aangesloten, ook rechtstreeks verbonden zijn met de USB-poort. Wanneer we dus met behulp van Serial.println(), data wilden wegschrijven naar de seri"ele monitor, gebeurde dat als het ware op dezelfde datalijn als de data die we ontvingen via de Bluetooth module. We konden dit probleem oplossen door niet langer gebruik te maken van Hardware Serial maar wel door Software Serial waarbij we de pinnen A2 en 2 gebruikten als respectievelijk RX en TX.

\subchapter{Hardware}
We waren er ons van bewust dat het vrijwel onmogelijk was dat onze PCB geen kinderziekten zou hebben bij de eerste uitvoering. Dit wisten we eigenlijk bijna zeker omdat we een probleem hadden bij de L298, het ground-vlak viel wat groter uit dan de voorziene plaats van de footprint. Dit ging daardoor contact maken met een baantje waarover +5V en dus eigenlijk kortsluiting maken. We hebben wat zitten denken en we hebben dit probleem opgelost door een plakker tussen het ground-vlak en het baantje te plakken waardoor ze dus geen contact konden maken. Dit was wel degelijk een oplossing voor dit probleem maar het was niet ideaal, dit was dus één van de redenen om een nieuwe printplaat te maken en dit te veranderen. We hadden ook problemen met de reset-knop, de afmetingen van de gebruikte footprint klopte ook niet. We moesten de resetknop anders dan normaal oriënteren omdat anders de verkeerde benen zouden verbonden zijn. We zien op de foto??%~\ref{fig:reset}
twee beentjes aan twee zijden, deze twee beentjes worden verbonden door de knop in te drukken. Bij ons waren de afmetingen van de footprint omgewisseld waardoor de niet-verbonden beentjes constant verbonden gingen zijn waardoor de reset knop de werking van de PCB zou verhinderen. We hebben dit opgelost door gebruik te maken van een drukknop met slechts twee pinnen die verbonden worden met elkaar bij het indrukken van de knop. We zaten dan wel met het probleem dat deze knop veel langer was en dus de pinnen een opvulvlak konden raken. Dit wilden we liever verhinderen waardoor we een stukje van het vlak vlak naast de drukknop losgemaakt hebben van een groter ander deel van dat vlak door koper weg te krassen. Hierdoor waren we zeker dat eventuele andere verbindingen door solderingen met dit vlak geen kortsluiting kon veroorzaken of andere problemen geven. We controleerden wel telkens dat geen enkele solduur contact maakte met een opvulvlak maar we kunnen altijd iets over het hoofd zien en we wilden geen risico’s nemen. Toen we na het vele controleren bij het overbrengen van de kabels van de Arduino + Motorshield naar de Ardumoto merkten dat als we spanning op de PCB aanlegden, een paar componenten warm werden en een elco zelfs gloeiend heet werd. We wisten dus dat er nog enkele problemen waren met de motoraansturing. We hebben na zeer lang zoeken en met hulp van onze coach 3 problemen ontdekt. We hebben deze problemen ook aangeduid op figuur??%~\ref{fig:PCBProblemen}
Probleem 1 was een Schottky-diode die niet goed verbonden was met zijn baantje. De diode maakte soms wel contact en soms niet. Daar de footprint nog steeds klein uitviel hebben we het opgelost door een extern draadje te strippen en aan het contactvlak te solderen en te verbinden met het baantje.
Probleem 2 was simpelweg een Via die we vergeten waren aan te leggen waardoor een pin van de L298 niet verbonden was. 
Probleem 3 was het de grootste boosdoener. We hebben in het schema vergeten de IC voor de motoraansturing te voeden met de PWRIN. Hierdoor werden de signalen niet goed verwerkt door de IC en kregen de motoren dus ook niet de goede signalen. We hebben dit nogmaals opgelost door een draad te strippen en de verbinding aan te leggen tussen de IC en de PWRIN. De PWRIN is het signaal dat rechtstreeks via de kroonsteentjes binnenkomt van de batterij. We hebben hiervoor gebruik gemaakt van een dikkere draad omdat er toch enkele volts door deze kabel moeten. 




